### **1. Variadic Templates Overview**

C++ variadic templates let you write templates that accept **any number of template parameters**:

```cpp
template<typename... Args>
void func(Args... args);
```

* `Args...` → template parameter pack (types)
* `args...` → function parameter pack (values)
* Key: **works with 0 or more parameters**.

---

# **2. Recursive Variadic Templates**

### **Syntax Example**

```cpp
template<typename T>
void print(T t) {
    std::cout << t << "\n"; // base case
}

template<typename T, typename... Ts>
void print(T t, Ts... ts) {
    std::cout << t << "\n";
    print(ts...); // recursive call
}
```

### **Compile-Time Behavior**

* Each recursion step → **new template instantiation**
* Compiler generates a **separate function for each “slice” of the pack**
* No generic recursion function exists at runtime

### **Runtime Behavior**

* At runtime, you just have **a chain of normal function calls**
* **No stack-growing recursion** occurs; depth is fully known at compile time
* Example call:

```cpp
print(1, 2.5, "hello");
```

Becomes, in effect:

```cpp
print<int, double, const char*>() → calls print<double, const char*>()
print<double, const char*>() → calls print<const char*>()
print<const char*>() → base case
```

* Assembly shows **calls to different functions**, not self-recursion

### **Pros & Cons**

* ✅ Works in C++11+
* ✅ Can handle heterogeneous types
* ❌ Slightly more verbose, base case needed
* ❌ Could generate many function instantiations for large packs

---

# **3. Fold Expressions (C++17+)**

### **Syntax Example**

```cpp
template<typename... Args>
void print(Args... args) {
    ((std::cout << args << "\n"), ...); // unary right fold
}
```

* `((expr), ...)` → right fold over parameter pack
* `(expr, ...)` evaluates `expr` for each argument in sequence
* Fold expression is **one single expression** → compiler unrolls at compile-time

### **Compile-Time Expansion**

```cpp
print(1, 2.5, "hello");
```

Becomes:

```cpp
(std::cout << 1 << "\n",
 std::cout << 2.5 << "\n",
 std::cout << "hello" << "\n");
```

* ✅ Linear sequence of expressions
* ✅ No recursion, no additional stack frames

### **Multiple Statements per Argument**

* Fold expressions **cannot directly expand multiple statements**
* Trick: wrap multiple statements in a lambda:

```cpp
template<typename... Args>
void print(Args... args) {
    auto f = [](auto arg) {
        std::cout << arg << "\n";
        log(arg);
        count++;
    };
    (f(args), ...); // fold over lambda calls
}
```

* Each `f(args)` = **single expression**
* Inside lambda → any number of statements

### **Pros & Cons**

* ✅ Zero runtime overhead
* ✅ Cleaner and safer than recursive template
* ✅ Works naturally with empty packs (use binary fold)
* ❌ Only works in C++17+

---

# **4. Stack & Memory Considerations (x86 example)**

For:

```cpp
print(1, 2.5, "hello");
```

32-bit x86 stack layout:

| Offset from EBP | Value              | Explanation               |
| --------------- | ------------------ | ------------------------- |
| `[ebp+8]`       | int 1              | first argument (4 bytes)  |
| `[ebp+0xc]`     | double 2.5 lower 4 | double split in two slots |
| `[ebp+0x10]`    | double 2.5 upper 4 | upper half of double      |
| `[ebp+0x14]`    | pointer "hello"    | third argument            |

* **Recursive template expansion** → compiler generates separate functions
* **Fold expression** → single function, compiler generates **linear instructions**

---

# **5. Key Differences: Recursive vs Fold**

| Feature             | Recursive Variadic Template            | Fold Expression                           |
| ------------------- | -------------------------------------- | ----------------------------------------- |
| Compilation         | C++11+                                 | C++17+                                    |
| Runtime calls       | Normal function calls (instantiations) | Linear sequence of instructions           |
| Stack frames        | One per function instantiation         | Minimal, like normal function             |
| Multiple statements | Easy (multiple lines allowed)          | Must wrap in lambda or use comma operator |
| Base case needed    | Yes                                    | No                                        |
| Efficiency          | Slightly slower (many functions)       | Zero-cost, optimal                        |

---

# **6. TL;DR / Cheat Sheet**

* **Template parameter pack** → compile-time types, no runtime memory
* **Function parameter pack** → runtime values, passed normally on stack/registers
* **Recursive variadic template** → expands into multiple functions, no runtime recursion
* **Fold expressions** → expand inline, linear code, minimal overhead
* **Multiple statements in fold** → wrap in lambda or use comma operator


