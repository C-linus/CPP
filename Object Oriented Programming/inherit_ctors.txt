### Inheriting Ctors



## ğŸ§© 1. What `using Base::Base;` actually affects

This syntax:

```cpp
using Base::Base;
```

**only affects constructors** â€” specifically **non-special** constructors of the base class.

So:

* âœ… It inherits normal constructors (parameterized, default, etc.)
* âŒ It does **not** inherit or generate:

  * copy constructor
  * move constructor
  * copy assignment operator
  * move assignment operator
  * destructor

Those are still handled by **the compilerâ€™s normal synthesis rules**, *not* by inheritance.

---

## âš™ï¸ 2. Letâ€™s categorize what the compiler can synthesize automatically

| Function                 | Name                  | Synthesized automatically?             | Can be inherited via `using Base::Base`?           |
| ------------------------ | --------------------- | -------------------------------------- | -------------------------------------------------- |
| Default constructor      | `T()`                 | âœ… (if needed and no user-defined ctor) | âœ… (if base has one and you use `using Base::Base`) |
| Parameterized ctors      | `T(int, â€¦)`           | âŒ (must define manually)               | âœ… (via `using Base::Base`)                         |
| Copy constructor         | `T(const T&)`         | âœ…                                      | âŒ                                                  |
| Move constructor         | `T(T&&)`              | âœ…                                      | âŒ                                                  |
| Copy assignment operator | `operator=(const T&)` | âœ…                                      | âŒ                                                  |
| Move assignment operator | `operator=(T&&)`      | âœ…                                      | âŒ                                                  |
| Destructor               | `~T()`                | âœ…                                      | âŒ                                                  |

So the **inheriting constructor mechanism** only copies over *user-declared base constructors* into the derived classâ€™s overload set.
The special member functions (`copy/move/dtor`) follow **their own synthesis rules**, separately.

---

## ğŸ§  3. How the compiler decides to synthesize *special member functions*

Every class in C++ automatically gets these six â€œspecial membersâ€ if you donâ€™t define them yourself:

1. Default constructor
2. Copy constructor
3. Copy assignment operator
4. Destructor
5. (C++11+) Move constructor
6. (C++11+) Move assignment operator

But theyâ€™re only **generated if needed**, and sometimes **deleted** automatically if the compiler canâ€™t safely create them.

Example:

```cpp
class Base {
public:
    Base() {}
    Base(const Base&) {}
    Base(Base&&) {}
    ~Base() {}
};

class Derived : public Base {
    std::string s;
};
```

Even though you didnâ€™t write them for `Derived`,
the compiler will synthesize:

* `Derived(const Derived&)` â†’ calls `Base(const Base&)` and copies `s`
* `Derived(Derived&&)` â†’ calls `Base(Base&&)` and moves `s`
* `Derived::~Derived()` â†’ calls `s.~string()` and `Base::~Base()`

ğŸ‘‰ **But these are not inherited from `Base`** â€” they are freshly *synthesized* for `Derived`.

---

## ğŸ”¬ 4. Why you canâ€™t â€œinheritâ€ copy/move constructors

The problem is *type safety*.
A base classâ€™s copy constructor has signature:

```cpp
Base(const Base&);
```

If that were inherited literally, youâ€™d have a constructor in `Derived` that takes a `Base const&`, not a `Derived const&`.

Thatâ€™s dangerous â€” copying a `Base` subobject doesnâ€™t copy the `Derived`-specific members.
So the C++ designers intentionally **forbid inheriting special members** like copy/move constructors.

Thatâ€™s why `using Base::Base;` doesnâ€™t bring them in.

---

## âš™ï¸ 5. Destructor and assignment operator synthesis

Similarly, destructors and assignment operators are **always synthesized per-class**, because each class might have different members to destroy or assign.

Example:

```cpp
class Base {
public:
    ~Base() { std::cout << "Base dtor\n"; }
};

class Derived : public Base {
    std::string s;
};
```

Even if you never write `~Derived()`, the compiler generates it as:

```cpp
Derived::~Derived() {
    s.~basic_string();
    Base::~Base();
}
```

and calls both destructors automatically.
You never need to inherit it.

---

## ğŸ§¬ 6. When compiler *deletes* special members

If a base or member is non-copyable/movable, the compiler may **delete** the derivedâ€™s version automatically.

Example:

```cpp
struct NonCopyable {
    NonCopyable(const NonCopyable&) = delete;
};

struct Derived : NonCopyable {};
```

Here, the compiler will **delete** `Derived(const Derived&)` too.

---

## âœ… 7. TL;DR Summary

| Category            | Can be inherited via `using Base::Base;` | Auto-synthesized for Derived | Notes                            |
| ------------------- | ---------------------------------------- | ---------------------------- | -------------------------------- |
| Normal constructors | âœ…                                        | âœ… (if needed)                | Forwards args to base            |
| Copy constructor    | âŒ                                        | âœ…                            | Calls `Base(const Base&)`        |
| Move constructor    | âŒ                                        | âœ…                            | Calls `Base(Base&&)`             |
| Destructor          | âŒ                                        | âœ…                            | Calls member dtors and base dtor |
| Copy assignment     | âŒ                                        | âœ…                            | Calls base & member copy ops     |
| Move assignment     | âŒ                                        | âœ…                            | Calls base & member move ops     |

So:

> `using Base::Base;` is **only for non-special constructors.**
> The rest (copy/move/dtor/operator=) are synthesized **per class**, never inherited.




