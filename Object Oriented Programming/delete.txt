### Delete operator


## ğŸ§© 1ï¸âƒ£ What `delete` actually does

When you write:

```cpp
delete ptr;
```

This is **not** just a single operation.
It actually expands conceptually into **three steps** (done by the compiler):

```cpp
if (ptr != nullptr) {
    ptr->~TypeOfPointer();  // (1) call destructor (statically or dynamically)
    operator delete(ptr);   // (2) deallocate memory from heap
}
```

So, what happens depends *entirely* on **how step (1)** works.

---

## âš™ï¸ 2ï¸âƒ£ Without `virtual` destructor

Letâ€™s say:

```cpp
Base* bp = new Derived();
delete bp;
```

Since `Base::~Base()` is **not virtual**, the compiler binds the destructor **statically** â€”
that means:

> It will *only call* `Base::~Base()` because thatâ€™s the type of the pointer.

No vtable lookup, no runtime check.

Then `operator delete(bp)` is called â€”
but it deallocates memory **as if the object were only a `Base`**.

Thatâ€™s dangerous because the memory that was actually allocated was **`sizeof(Derived)`**, not `sizeof(Base)`!

---

### ğŸ§  Visualize the memory

```
Heap:
+-----------------------+
| Derived::data_members |
| Base::data_members    |
+-----------------------+
^
bp points here (Base subobject start)
```

Now `delete bp` does:

1ï¸âƒ£ Calls only `Base::~Base()` â†’ Derived part untouched (no cleanup).
2ï¸âƒ£ Calls `operator delete(bp, sizeof(Base))` â†’ may free memory incorrectly.

Thatâ€™s why **itâ€™s undefined behavior** â€” sometimes it leaks, sometimes it corrupts the heap.

---

## âš™ï¸ 3ï¸âƒ£ With `virtual` destructor

Now, if you mark:

```cpp
class Base {
public:
    virtual ~Base() { cout << "Base destroyed\n"; }
};
```

Then, when you do:

```cpp
Base* bp = new Derived();
delete bp;
```

The compiler generates code that:
1ï¸âƒ£ Looks up the destructor **through the vtable** (using the vptr).
2ï¸âƒ£ Finds that the **actual destructor** is `Derived::~Derived()`.
3ï¸âƒ£ Calls it â€” which itself calls `Base::~Base()` afterward.
4ï¸âƒ£ Calls `operator delete` with the **correct size** (that of `Derived`).

âœ… Derived cleaned
âœ… Base cleaned
âœ… Heap correctly freed

---

## ğŸ§± 4ï¸âƒ£ So, your statement is perfectly right:

> â€œThe `delete` keyword only deletes the `sizeof(type_of_pointer)` provided to it, not the actual size of the memory allocated in heap.â€

Exactly âœ… â€” unless the destructor is **virtual**, because only then the compiler *knows how to reach the right deallocation logic* for the true object type.

---

## âš ï¸ 5ï¸âƒ£ Subtle detail

If you override `operator delete` in the derived class, the compiler will only call it if the destructor is **virtual**.
Otherwise, even that will be ignored â€” the baseâ€™s delete operator will be used, which is another source of memory bugs.

---

## ğŸ”¥ TL;DR

| Case        | Destructor call               | Deallocation size | Safe?       |
| ----------- | ----------------------------- | ----------------- | ----------- |
| Non-virtual | Static (`Base::~Base`)        | `sizeof(Base)`    | âŒ Undefined |
| Virtual     | Dynamic (`Derived::~Derived`) | `sizeof(Derived)` | âœ… Safe      |

