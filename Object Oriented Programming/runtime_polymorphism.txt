### ðŸ“ C++ Runtime Polymorphism: vptr & vtable Explained

## 1ï¸âƒ£ **Each class with virtual functions gets a vtable**

* The **compiler** creates a hidden table (usually in `.rdata` or `.rodata`) containing **pointers to that classâ€™s virtual functions**.
* Example:

```
Base::vtable     â†’ [ &Base::show ]
Derived::vtable  â†’ [ &Derived::show ]
```

* The vtable is **class-specific**, not object-specific.

---

## 2ï¸âƒ£ **Each object has a hidden pointer: `vptr`**

* The compiler inserts a hidden member called **vptr** (virtual pointer) inside every object with virtual functions.
* **Usually placed at the very beginning of the object** (offset 0) for fast access.
* The **vptr points to the vtable of the object's actual type**.

---

## 3ï¸âƒ£ **Constructors initialize the vptr**

* During object construction, constructors run **from base â†’ derived**.
* Each constructor **sets the vptr** to its own classâ€™s vtable:

```cpp
Derived d;
```

Execution order:

1. `Base::Base()` â†’ sets `vptr = &Base::vtable`
2. `Derived::Derived()` â†’ overwrites `vptr = &Derived::vtable`

âœ… After construction, `d.vptr` points to `Derived::vtable`.

---

## 4ï¸âƒ£ **Virtual function call mechanism at runtime**

When you write:

```cpp
Base* bp = &d;
bp->show();  // virtual call
```

The CPU executes something like:

```asm
mov eax, [bp]          ; load vptr from object
mov eax, [eax + offset] ; load function pointer from vtable
call eax               ; jump to actual function
```

* The **pointer type (`Base*`) does not matter** â€” the vptr points to the correct vtable.
* The **actual function called depends on the objectâ€™s dynamic type**.

---

## 5ï¸âƒ£ **Memory layout example**

```cpp
class Base { virtual void f(); int x; };
class Derived : public Base { virtual void g(); int y; };
```

| Offset | Member                                                  |
| ------ | ------------------------------------------------------- |
| 0      | **vptr** â†’ points to Derived::vtable after Derived ctor |
| 4      | Base::x                                                 |
| 8      | Derived::y                                              |

---

## 6ï¸âƒ£ **Key points**

* Each object with virtuals has **its own vptr**.
* The vptr is **automatically inserted** by the compiler.
* The vptr is **first in the object** for single inheritance.
* **Virtual calls** use the vptr â†’ vtable pointer to call the right function at runtime.
* The vtable contains **all virtual function addresses** of that class; the compiler decides the **offset at compile-time**.

---

## 7ï¸âƒ£ **Summary table**

| Concept          | Stored in           | Description                                                    |
| ---------------- | ------------------- | -------------------------------------------------------------- |
| **vptr**         | Inside each object  | Points to the classâ€™s vtable                                   |
| **vtable**       | In `.rdata` section | Contains addresses of that classâ€™s virtual functions           |
| **Constructor**  | Code section        | Initializes or overwrites `vptr` as it walks inheritance chain |
| **Virtual call** | Runtime dispatch    | Fetches function address from vtable and jumps there           |

---

ðŸ’¡ **Takeaway:**

> The inheritance hierarchy during constructor execution ensures that the objectâ€™s vptr points to the **correct vtable**. Thatâ€™s why virtual function calls **always resolve to the right function**, even when accessed via a base class pointer.


